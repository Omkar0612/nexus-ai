package forge

import (
	"context"
	"fmt"
	"io"

	"github.com/Omkar0612/nexus-ai/internal/plugin/wasm"
	"github.com/rs/zerolog/log"
)

// Forge is the autonomous factory that takes pure Go code (generated by an LLM),
// compiles it to Wasm, and injects it into the running system.
type Forge struct {
	localCompiler Compiler
	cloudCompiler Compiler
	wasmRuntime   *wasm.Runtime
}

// New initializes the Auto-Forge engine.
func New(wasmRuntime *wasm.Runtime) *Forge {
	return &Forge{
		localCompiler: NewLocalCompiler(),
		cloudCompiler: NewCloudCompiler(""),
		wasmRuntime:   wasmRuntime,
	}
}

// BuildAndLoad handles the entire lifecycle: compiling source to WASM, 
// hot-loading it, and returning the active sandboxed AgentModule.
func (f *Forge) BuildAndLoad(ctx context.Context, name, sourceCode string, stdout io.Writer) (*wasm.AgentModule, error) {
	log.Info().Str("agent", name).Msg("Forging new agent from source...")

	var wasmBytes []byte
	var err error

	// 1. Try local TinyGo compiler first (fastest, private)
	wasmBytes, err = f.localCompiler.Compile(ctx, sourceCode)
	if err != nil {
		log.Warn().Err(err).Msg("Local TinyGo compilation failed or unavailable. Falling back to NEXUS Cloud Compiler...")
		
		// 2. Fallback to Cloud Compiler (no dependencies required for user)
		wasmBytes, err = f.cloudCompiler.Compile(ctx, sourceCode)
		if err != nil {
			return nil, fmt.Errorf("both local and cloud compilation failed. Cloud error: %w", err)
		}
		log.Info().Msg("Cloud compilation successful.")
	} else {
		log.Info().Msg("Local compilation successful.")
	}

	// 3. Hot-load the compiled bytes into the Zero-Trust Wasm Sandbox
	agent, err := f.wasmRuntime.LoadAgent(name, wasmBytes, stdout)
	if err != nil {
		return nil, fmt.Errorf("failed to hot-load compiled agent: %w", err)
	}

	log.Info().Str("agent", name).Msg("Agent successfully forged and hot-loaded into NEXUS.")
	return agent, nil
}
